#!/usr/bin/perl
use strict;
use Getopt::Long;
use Sys::Hostname;
#
#############################################################################
#
# sapha_get_nodes
#
#############################################################################
#
# list corosync cluster nodes for several query types
#
#############################################################################
#
# SYNOPSIS sapha_get_nodes --out file --rsc resource | --all | --type active|standby|all 
#
# PARAMETERS
#     --out file
#     --rsc resource
#     --all
#     --type active|standby|all
#
# OUTPUT: one single line with the following format:
#    RSC:MYNAME:CURRNODE:NODELIST
#
# RETURN VALUES:
#    0: if everything wents well
#    2: on any error
#
# EXTERNAL PROGRAMMS
#    ptest (ptest -Ls)
#    crm_resource (crm_resource -W -r RSC)
#
##############################################################################
#
## GPL
#
# Author: Fabian Herschel
# (c) 2011 SUSE Linux Products GmbH, Nuremberg, Germany
#
##############################################################################

my $outfile = "";
my $resource = "";

my $result = GetOptions ("out=s" => \$outfile,    
			 "rsc=s" => \$resource,
		);

#printf "DBG: GetOptions result: %s\n", $result;

if (!($result)) {
	exit 2;
}

#
# 1. GET HOSTNAME WHERE FUNCTION WAS CALLED
#
my $myhostname = hostname;
#
##########################
#
# 2. GET NODE NAME, WHERE RESOURCE IS CURRENTLY RUNNING
#
# to get the current location of the resource in the cluster, lets ask the cluster itself ;-)
# we assume to get an answer in the following format:
#
# resource RES is running on: NODE
#
open CRMRES, "crm_resource -W -r $resource|";
my $crm_res_location_in = <CRMRES>;
chomp $crm_res_location_in;
#printf "DBG: where-result: %s\n", $crm_res_location_in;
my $current_node="";
if ( $crm_res_location_in =~ /^resource\s+(\w)+\sis running on:\s+(\w+)\W*/ ) {
	#printf "DBG: where-result: match\n";
	$current_node = $2;
}
close CRMRES;
#
##########################
#
# 3. GET ORDERED LIST OF CLUSTER NODES WHICH COULD RUN THE RESOURCE
#
my $node_list="";
my %resource;
open PTEST, "ptest -Ls |" || die "Not able to analyse ptest";
#
# we rely on the following format:
#
#   ...
#   group_color: RSC allocation score on NODE: VALUE
#   ...
#   native_color: RSC allocation score on NODE: VALUE
#
while (<PTEST>) {
	chomp;
	# printf "%s\n", $_;
	if ( /^group_color:\s*(\w+)\s+allocation score on\s+(\w+):\s+(.*)$/ ) {
		# printf "DBG: group 1: %s, 2: %s, 3: %s\n", $1, $2, $3;
		$resource{$1}->{nodes}->{$2}->{gc}=$3;
		push(@{$resource{$1}->{priorities}->{$3}}, $2);
	}
	if ( /^native_color:\s*(\w+)\s+allocation score on\s+(\w+):\s+(.*)$/ ) {
		# printf "DBG: native 1: %s, 2: %s, 3: %s\n", $1, $2, $3;
		$resource{$1}->{nodes}->{$2}->{nc}=$3;
		push(@{$resource{$1}->{priorities}->{$3}}, $2);
	}
}
close PTEST;
#
# get sorted list of scores (excluding -INFINITY)
#
my @filtered_prios=grep (!/-INFINITY/, keys (%{$resource{$resource}->{priorities}}));
@filtered_prios=sort {$b <=> $a} @filtered_prios; # reverse order
#
# figure out node list sorted by prios (scores)
#
my $prio;
my $node;
my @nodes;
my %node_mark;
for $prio ( @filtered_prios ) {
	#printf "for prio %s checking nodes %s\n", $prio, join " ",@{$resource{$resource}->{priorities}->{$prio}};
	for $node ( @{$resource{$resource}->{priorities}->{$prio}} ) {
		if ( ! defined ( $node_mark{$node} )) {
			#printf "DBG: for prio %s adding node %s\n", $prio, $node;
			$node_mark{$node}=1;
			push(@nodes, $node);
		} 
	}
}
$node_list = join ",", @nodes;
#
# SOME MORE DBG
#
#my @allnodes=keys(%{$resource{$resource}->{nodes}});
#printf "DBG: %s all nodes: %s\n", $resource, join(",", @allnodes);
#printf "DBG: %s prios: %s\n", $resource, join(" ", @filtered_prios);
#printf "DBG: %s ordered nodes %s\n", $resource, join(" ", @nodes);
#
# RESULT
# 
if ( $outfile ne "" ) {
	open OUTFILE, ">$outfile";
	printf OUTFILE "%s:%s:%s:%s\n",  $resource, $myhostname, $current_node, $node_list;
	close OUTFILE;
} else {
	printf "%s:%s:%s:%s\n",  $resource, $myhostname, $current_node, $node_list;
}
exit 0;
